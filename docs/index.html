<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>GnosisSafeExplorer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="description" content="GnosisSafeExplorer (c) Bok Consulting Pty Ltd 2025" />
    <meta name="author" content="BokkyPooBah" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@BokkyPooBah" />
    <meta name="twitter:creator" content="@BokkyPooBah" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap.min.css" />
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/bootstrap-vue-icons.min.css"/>
    <link type="text/css" rel="stylesheet" href="css/app.css" />
    <script src="js/vue.js"></script>
    <script src="js/bootstrap-vue.min.js"></script>
    <script src="js/bootstrap-vue-icons.min.js"></script>
    <script src="js/ethers-5.7.umd.min.js" type="application/javascript"></script>
    <script src="js/moment.min.js"></script>
    <script src="js/dexie.js"></script>
    <script src="safeAddresses.js"></script>
    <script src="globals.js"></script>
    <script src="chains.js"></script>
    <script src="customNames.js"></script>
    <script src="deploymentData.js"></script>
    <script src="inferTxInfo.js"></script>
    <script src="parseEtherscan.js"></script>
    <script src="parseReservoir.js"></script>

    <link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon-16x16.png">
    <link rel="manifest" href="images/site.webmanifest">
    <link rel="mask-icon" href="images/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="shortcut icon" href="images/favicon.ico">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="msapplication-config" content="images/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
  </head>
  <body>
    <div id="app">
      <b-container fluid class="m-0 p-0">
        <b-navbar toggleable="sm" variant="light" class="mx-1 my-0 p-0">
          <b-navbar-brand to="https://bokkypoobah.github.io/GnosisSafeExplorer/" variant="primary">
            <b-avatar rounded variant="light" size="3.0rem" src="images/ZombieBaby_004_transparentbg_zoomed.png" v-b-popover.hover.bottom="'gm'" class="ml-0"></b-avatar>
            <font size="-1" v-b-popover.hover.bottom="'gm gm gm'">GnosisSafeExplorer</font>
          </b-navbar-brand>
          <b-navbar-nav class="ml-auto">
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 0; saveSettings();" :active="settings.tabIndex == 0" active-class="active" v-b-popover.hover="'Scan'">Scan</b-nav-item> -->
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 1; saveSettings();" :active="settings.tabIndex == 1" active-class="active" v-b-popover.hover="'Actions'">Actions</b-nav-item> -->
            <!-- <b-nav-item size="sm" @click="settings.tabIndex = 0; saveSettings();" :active="settings.tabIndex == 0" active-class="active" v-b-popover.hover="'Approvals'">Approvals</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 1; saveSettings();" :active="settings.tabIndex == 1" active-class="active" v-b-popover.hover="'Events'">Events</b-nav-item>
            <b-nav-item size="sm" @click="settings.tabIndex = 2; saveSettings();" :active="settings.tabIndex == 2" active-class="active" v-b-popover.hover="'Accounts'">Accounts</b-nav-item> -->
            <!-- <b-avatar v-if="coinbase && coinbase != nameOrShortAddress(coinbase)" rounded variant="light" size="3.0rem" :src="'https://metadata.ens.domains/mainnet/avatar/' + nameOrShortAddress(coinbase, 100)" v-b-popover.hover="'Your ENS avatar if set'"></b-avatar> -->
            <!-- <b-button size="sm" variant="outline-primary" class="ml-1 mr-1" @click="connectToWeb3(); processNewBlock(0);" v-b-popover.hover.bottom="'Click to update wallet'">{{ coinbase ? nameOrShortAddress(coinbase, 16) : 'Connect' }}</b-button> -->
            <b-button size="sm" variant="outline-primary" class="ml-1 mr-1" @click="connectToWeb3(); processNewBlock(0);" v-b-popover.hover.bottom="'Click to update wallet'">{{ coinbase ? coinbase.substring(0, 16) : 'Connect' }}</b-button>
          </b-navbar-nav>
        </b-navbar>

        <!-- <b-alert v-if="false" size="sm" dismissible variant="warning" show class="m-1 my-0">
          Warning: This is experimental unaudited software. Please check your transaction data carefully before signing
        </b-alert> -->
        <!-- <b-card class="m-2 p-1" header-class="warningheader" header="Welcome" v-if="false && !coinbase">
          <b-card-text>
            Please install the MetaMask extension and connect to the Ethereum Mainnet or an EVM compatible chain. Then refresh this page, and click the [Connect] button on the top right.
          </b-card-text>
        </b-card> -->

        <!-- :MODALSAFE -->
        <b-modal id="modal-safe" hide-footer size="lg" body-class="m-0 p-1 pt-2" body-bg-variant="light">
          <template #modal-title>
            Safe {{ modalSafe.safe || '' }}
          </template>
          <b-form-group label="Safe:" label-cols="4" label-align="right" class="m-0 p-0">
            <b-input-group>
              <b-button v-if="modalSafe.safe" :href="'https://etherscan.io/address/' + lookupAddress(modalSafe.safe)" variant="link" target="_blank" class="m-0 p-0 pt-1">
                {{ lookupName(modalSafe.safe) }}
              </b-button>
              <b-input-group-append>
                <b-button size="sm" @click="copyToClipboard(lookupAddress(modalSafe.safe));" variant="link">
                  <b-icon-clipboard shift-v="-1" font-scale="1.1"></b-icon-clipboard>
                </b-button>
                <b-button v-if="modalSafe.safe" size="sm" :href="'https://app.safe.global/transactions/history?safe=eth:' + lookupAddress(modalSafe.safe)" v-b-popover.hover.bottom="'View in app.safe.global'" variant="link" target="_blank">
                  <b-icon-wallet shift-v="-1" font-scale="1.1"></b-icon-wallet>
                </b-button>
              </b-input-group-append>
            </b-input-group>
          </b-form-group>
          <b-form-group label="Factory:" label-cols="4" label-align="right" class="m-0 p-0" :description="modalSafe.info.factoryVersion && ('Safe Factory v' + modalSafe.info.factoryVersion) || ''">
            <b-input-group>
              <b-button v-if="modalSafe.factory" :href="'https://etherscan.io/address/' + lookupAddress(modalSafe.factory)" variant="link" target="_blank" class="m-0 p-0 pt-1">
                {{ lookupName(modalSafe.factory) }}
              </b-button>
              <b-input-group-append>
                <b-button size="sm" @click="copyToClipboard(lookupAddress(modalSafe.factory));" variant="link">
                  <b-icon-clipboard shift-v="-1" font-scale="1.1"></b-icon-clipboard>
                </b-button>
              </b-input-group-append>
            </b-input-group>
          </b-form-group>
          <b-form-group label="Safe Implementation:" label-cols="4" label-align="right" class="m-0 p-0" :description="modalSafe.info.safeVersion && ('Safe v' + modalSafe.info.safeVersion) || ''">
            <b-input-group>
              <b-button v-if="modalSafe.info.implementation" :href="'https://etherscan.io/address/' + lookupAddress(modalSafe.info.implementation)" variant="link" target="_blank" class="m-0 p-0 pt-1">
                {{ lookupName(modalSafe.info.implementation) }}
              </b-button>
              <b-input-group-append>
                <b-button v-if="modalSafe.info.implementation" size="sm" @click="copyToClipboard(lookupAddress(modalSafe.info.implementation));" variant="link">
                  <b-icon-clipboard shift-v="-1" font-scale="1.1"></b-icon-clipboard>
                </b-button>
              </b-input-group-append>
            </b-input-group>
          </b-form-group>
          <b-form-group label="Owners:" label-cols="4" label-align="right" class="m-0">
            <div v-for="(owner, index) of (modalSafe.info.owners || [])" v-bind:key="index">
              <b-input-group>
                <b-button :href="'https://etherscan.io/address/' + lookupAddress(owner)" variant="link" target="_blank" class="m-0 p-0 pt-1">
                  {{ lookupName(owner) }}
                </b-button>
                <b-input-group-append>
                  <b-button size="sm" @click="copyToClipboard(lookupAddress(owner));" variant="link">
                    <b-icon-clipboard shift-v="-1" font-scale="1.1"></b-icon-clipboard>
                  </b-button>
                </b-input-group-append>
              </b-input-group>
            </div>
          </b-form-group>
          <b-form-group label="Threshold:" label-cols="4" label-align="right" class="m-0">
            <b-form-input type="text" readonly size="sm" :value="modalSafe.info.threshold" class="w-25"></b-form-input>
          </b-form-group>
          <b-form-group label="Nonce:" label-cols="4" label-align="right" class="m-0">
            <b-form-input type="text" readonly size="sm" :value="modalSafe.info.nonce" class="w-25"></b-form-input>
          </b-form-group>
          <!-- <font size="-2">
            <pre>
{{ modalSafe }}
            </pre>
          </font> -->
          <!-- :MENU -->
          <div class="d-flex flex-wrap m-0 mt-1 p-0 px-1 pt-1 bg-white">
            <!-- <div class="mt-0 pr-1" style="max-width: 24.0rem;">
              <b-form-input type="text" size="sm" v-model.trim="settings.safeTxsTable.filter" @change="saveSettings(); loadCurrentData();" debounce="600" v-b-popover.hover.bottom="'Filter by safe address'" placeholder="🔍 0xabcd"></b-form-input>
            </div> -->
            <div class="mt-0 flex-grow-1">
            </div>
            <!-- <div v-if="!sync.section" class="mt-0 pr-1">
              <b-button size="sm" @click="retrieveSafeFactoryEvents()" variant="primary" v-b-popover.hover.bottom="'Retrieve Safe Events'">Sync</b-button>
            </div> -->
            <!-- <b-progress v-if="sync.section != null" height="2.0rem" :max="sync.total" show-progress :animated="sync.section != null" :variant="sync.section != null ? 'success' : 'secondary'" class="m-0 p-0" style="min-width: 24.0rem;">
              <b-progress-bar :value="sync.completed">
                {{ sync.total == null ? (sync.completed + ' ' + sync.section) : (sync.completed + '/' + sync.total + ' ' + ((sync.completed / sync.total) * 100).toFixed(0) + '% ' + sync.section) }}
              </b-progress-bar>
            </b-progress> -->
            <!-- <div class="mt-0 flex-grow-1">
            </div> -->
            <div class="mt-0 pl-1">
              <b-form-select size="sm" v-model="settings.safeTxsTable.sortOption" @change="saveSettings" :options="safeTxsSortOptions" v-b-popover.hover.bottom="'Yeah. Sort'"></b-form-select>
            </div>
            <div class="mt-0 pl-1">
              <font size="-2" v-b-popover.hover.bottom="'# Safes'">{{ modalSafeTxs.length }}</font>
            </div>
            <div class="mt-0 pl-1">
              <b-pagination size="sm" v-model="settings.safeTxsTable.currentPage" @input="saveSettings" :total-rows="modalSafeTxs.length" :per-page="settings.safeTxsTable.pageSize" style="height: 0;"></b-pagination>
            </div>
            <div class="mt-0 pl-1">
              <b-form-select size="sm" v-model="settings.safeTxsTable.pageSize" @change="saveSettings" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
            </div>
          </div>
          <!-- <b-table ref="safeTxsTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='safesRowSelected' :fields="safesFields" :items="pagedFilteredSortedSafes" show-empty empty-html="Click Sync above to retrieve all deployed Safes v1.1.1, v1.3.0 and v1.4.1" head-variant="light" class="mx-0 my-0"> -->
          <b-table ref="safeTxsTable" small fixed striped responsive hover :fields="safeTxsFields" :items="pagedFilteredSortedModalSafeTxs" show-empty empty-html="Retrieving..." head-variant="light" class="mx-0 mt-1">
            <template #cell(index)="data">
              <font size="-1" class="text-muted">
                {{ parseInt(data.index) + ((settings.safeTxsTable.currentPage - 1) * settings.safeTxsTable.pageSize) + 1 }}
              </font>
            </template>
            <template #cell(info)="data">
              <b-link :href="'https://etherscan.io/tx/' + data.item.txHash" target="_blank">
                {{ timestamps[chainId] && timestamps[chainId][data.item.blockNumber] && formatTimestamp(timestamps[chainId][data.item.blockNumber]) || (data.item.blockNumber + ':' + data.item.txIndex) }}
              </b-link>
              <br />
              From:
              <b-link v-if="data.item.tx && data.item.tx.from" :href="'https://etherscan.io/address/' + lookupAddress(data.item.tx.from)" target="_blank">
                {{ lookupName(data.item.tx.from) }}
              </b-link>
              <br />
              To:
              <b-link v-if="data.item.tx && data.item.tx.to" :href="'https://etherscan.io/address/' + lookupAddress(data.item.tx.to)" target="_blank">
                {{ lookupName(data.item.tx.to) }}
              </b-link>
              <hr />
              <font size="-2">
                <pre>
{{ data.item }}
                </pre>
              </font>
            </template>
          </b-table>
        </b-modal>

        <b-card no-body class="p-0 mt-0 border-0" style="min-height: 600px;">
          <!-- :MENU -->
          <div class="d-flex flex-wrap m-0 mt-1 p-0 px-1 bg-white">
            <div class="mt-0 pr-1" style="max-width: 24.0rem;">
              <b-form-input type="text" size="sm" v-model.trim="settings.safesTable.filter" @change="saveSettings(); loadCurrentData();" debounce="600" v-b-popover.hover.bottom="'Filter by safe address'" placeholder="🔍 0xabcd"></b-form-input>
            </div>
            <div class="mt-0 pr-1">
              <b-dropdown size="sm" right text="" variant="link" class="m-0 p-0">
                <b-dropdown-text>Sample Safes</b-dropdown-text>
                <b-dropdown-divider></b-dropdown-divider>
                <b-dropdown-item @click="settings.safesTable.filter = '0x9fC3dc011b461664c835F2527fffb1169b3C213e'; saveSettings(); loadCurrentData()">EF: DeFi Multisig - Safe v1.4.1</b-dropdown-item>
                <b-dropdown-item @click="settings.safesTable.filter = '0x1Db92e2EeBC8E0c075a02BeA49a2935BcD2dFCF4'; saveSettings(); loadCurrentData()">Hacked Bybit: Cold Wallet 1 - Originally Safe 1.3.0; now Non-Safe Contract</b-dropdown-item>
              </b-dropdown>
            </div>
            <div class="mt-0 flex-grow-1">
            </div>
            <div v-if="!sync.section" class="mt-0 pr-1">
              <b-button size="sm" @click="retrieveSafeFactoryEvents()" variant="primary" v-b-popover.hover.bottom="'Retrieve Safe Events'">Sync</b-button>
            </div>
            <div v-if="!sync.section" class="mt-0 pr-1">
              <b-button size="sm" @click="retrieveSafeEvents()" variant="primary" v-b-popover.hover.bottom="'Dev Button'">Dev</b-button>
            </div>
            <div class="mt-0 pr-1">
              <b-progress v-if="sync.section != null" height="2.0rem" :max="sync.total" show-progress :animated="sync.section != null" :variant="sync.section != null ? 'success' : 'secondary'" class="m-0 p-0" style="min-width: 24.0rem;">
                <b-progress-bar :value="sync.completed">
                  {{ sync.total == null ? (sync.completed + ' ' + sync.section) : (sync.completed + '/' + sync.total + ' ' + ((sync.completed / sync.total) * 100).toFixed(0) + '% ' + sync.section) }}
                </b-progress-bar>
              </b-progress>
            </div>
            <div class="mt-0 flex-grow-1">
            </div>
            <div class="mt-0 pl-1">
              <b-form-select size="sm" v-model="settings.safesTable.sortOption" @change="saveSettings" :options="safesSortOptions" v-b-popover.hover.bottom="'Yeah. Sort'"></b-form-select>
            </div>
            <div class="mt-0 pl-1">
              <font size="-2" v-b-popover.hover.bottom="'# Safes'">{{ allSafes.length }}</font>
            </div>
            <div class="mt-0 pl-1">
              <b-pagination size="sm" v-model="settings.safesTable.currentPage" @input="saveSettings" :total-rows="allSafes.length" :per-page="settings.safesTable.pageSize" style="height: 0;"></b-pagination>
            </div>
            <div class="mt-0 pl-1">
              <b-form-select size="sm" v-model="settings.safesTable.pageSize" @change="saveSettings" :options="pageSizes" v-b-popover.hover.bottom="'Yeah. Page size'"></b-form-select>
            </div>
          </div>

          <b-card no-body class="m-1 p-0 border-0" bg-variant="light">
            <b-table ref="safesTable" small fixed striped responsive hover selectable select-mode="single" @row-selected='safesRowSelected' :fields="safesFields" :items="pagedFilteredSortedSafes" show-empty empty-html="Click Sync above to retrieve Safes deployed by Safe factories v1.0.0, v1.1.1, v1.3.0 and v1.4.1" head-variant="light" class="mx-0 my-0">
              <template #cell(index)="data">
                <font size="-1" class="text-muted">
                  {{ parseInt(data.index) + ((settings.safesTable.currentPage - 1) * settings.safesTable.pageSize) + 1 }}
                </font>
              </template>
              <template #cell(chain)="data">
                <div v-if="data.item.chainId == 1">
                  ETH Mainnet
                </div>
                <div v-else>
                  {{ "Chain Id " + data.item.chainId }}
                </div>
              </template>
              <template #cell(blockNumber)="data">
                <b-link :href="'https://etherscan.io/tx/' + indexToTxHash[data.item.txHashIndex] + '#eventlog#' + data.item.logIndex" target="_blank">
                  {{ data.item.blockNumber }}
                </b-link>
                <font size="-2" class="text-muted">
                  {{ data.item.logIndex }}
                </font>
              </template>
              <template #cell(safe)="data">
                <b-link :href="'https://etherscan.io/address/' + lookupAddress(data.item.safeAddressIndex)" target="_blank">
                  {{ lookupName(data.item.safeAddressIndex) }}
                </b-link>
                <b-link :href="'https://app.safe.global/transactions/history?safe=eth:' + lookupAddress(data.item.safeAddressIndex)" v-b-popover.hover.bottom="'View in app.safe.global'" target="_blank">
                  <b-icon-wallet shift-v="+2" font-scale="0.9" variant="primary"></b-icon-wallet>
                </b-link>
              </template>
              <template #cell(factory)="data">
                <b-link :href="'https://etherscan.io/address/' + lookupAddress(data.item.factoryAddressIndex)" target="_blank">
                  {{ lookupName(data.item.factoryAddressIndex) }}
                </b-link>
              </template>
            </b-table>

            <!-- <b-form-group label="" label-cols="3" label-align="right" class="m-0 mt-2" :description="!connected ? 'Click [Connect] to connect to Ethereum mainnet' : ''">
              <b-button size="sm" @click="retrieveSafeFactoryEvents();" variant="primary">
                Retrieve Safe Factory Events
              </b-button>
            </b-form-group> -->
          </b-card>

          <!-- :INFO -->
          <b-card v-if="false && (settings.mode == 'info' || (settings.mode == 'card' && Object.keys(settings.cards).length == 0))" no-body class="m-1 p-1 border-0" bg-variant="light">
            <b-card-body class="mt-1 p-1">
              <h6>Welcome to GnosisSafeExplorer (WIP)</h6>

              <!-- <br />

              1. Click [Connect] on the top right -->

              <br />
              <br />

              We are not affiliated with Gnosis .
              <!-- <br />
              <font size="-1">Enjoy!</font>
              <br />
              <font size="-1">(c) BokkyPooBah / Bok Consulting Pty Ltd 2025. The MIT Licence</font> -->
            </b-card-body>
          </b-card>
        </b-card>

        <b-card no-header body-class="m-0 p-0" class="m-0 p-0 border-0">
          <div class="d-flex flex-wrap m-0 p-0">
            <div class="ml-0 mt-1 pl-1">
              <font v-if="connected" size="-2">
                <!-- <b-link v-if="coinbase" :href="'https://etherscan.io/address/' + coinbase" v-b-popover.hover.bottom="'Coinbase'" target="_blank">
                  {{ coinbase.substring(0, 10) }}
                </b-link> -->
                <b-link v-if="chainId" :href="'https://etherscan.io/'" v-b-popover.hover.bottom="'Network'" target="_blank">
                  {{ chainId == '1' ? 'Mainnet' : 'Unsupported' }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="'Latest block'" target="_blank">
                  {{ '#' + commify0(blockNumber) }}
                </b-link>
                <b-link v-if="blockNumber" :href="'https://etherscan.io/block/' + blockNumber" v-b-popover.hover.bottom="formatTimestamp(timestamp)" target="_blank">
                  {{ formatTimeDiff(timestamp) }}
                </b-link>
              </font>
            </div>
            <div class="mt-0 flex-grow-1">
            </div>
            <div class="mt-0 pl-1 pr-1">
              <font size="-1">
                gm, and enjoy! <i>GnosisSafeExplorer</i> &copy; Bok Consulting Pty Ltd 2025. The MIT Licence
              </font>
            </div>
          </div>
        </b-card>
      </b-container>
    </div>

    <script>
      window.app = new Vue({
        el: '#app',
        // --- DATA ---
        data: {

          addressToIndex: {},
          indexToAddress: [],
          txHashToIndex: {},
          indexToTxHash: [],

          safes: {},

          connected: false,
          chainId: null,
          coinbase: null,
          blockNumber: null,
          timestamp: null,

          settings: {
            safesTable: {
              filter: null,
              currentPage: 1,
              pageSize: 15,
              sortOption: 'blocknumberdsc',
            },
            safeTxsTable: {
              filter: null,
              currentPage: 1,
              pageSize: 15,
              sortOption: 'blocknumberdsc',
            },
            version: 2,
          },

          modalSafe: {
            chainId: null,
            safeAddressIndex: null,
            safe: null,
            blockNumber: null,
            logIndex: null,
            txHashIndex: null,
            factoryAddressIndex: null,
            factory: null,
            info: {},
            events: {},
          },

          sync: {
            section: null,
            total: null,
            completed: null,
            error: null, // TODO
            // halt: false,
          },

          timestamps: {},
          txData: {}, // Transactions only for the current safe address

          safeTxsSortOptions: [
            // { value: 'addressasc', text: '▲ Addr' },
            // { value: 'addressdsc', text: '▼ Addr' },
            { value: 'blocknumberasc', text: '▲ BlockNumber, ▲ TxIndex' },
            { value: 'blocknumberdsc', text: '▼ BlockNumber, ▼ TxIndex' },
          ],
          safesSortOptions: [
            // { value: 'addressasc', text: '▲ Addr' },
            // { value: 'addressdsc', text: '▼ Addr' },
            { value: 'blocknumberasc', text: '▲ BlockNumber, ▲ LogIndex' },
            { value: 'blocknumberdsc', text: '▼ BlockNumber, ▼ LogIndex' },
          ],
          pageSizes: [
            { value: 2, text: '2' },
            { value: 5, text: '5' },
            { value: 10, text: '10' },
            { value: 15, text: '15' },
            { value: 25, text: '25' },
            { value: 50, text: '50' },
            { value: 100, text: '100' },
            { value: 250, text: '250' },
            { value: 500, text: '500' },
            { value: 1000, text: '1,000' },
          ],

          safeTxsFields: [
            { key: 'index', label: '#', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
            { key: 'info', label: 'Info', sortable: false, thStyle: 'width: 90%;', tdClass: 'text-truncate' },
            // { key: 'blockNumber', label: 'Block # / Log Index', sortable: false, thStyle: 'width: 13%;', tdClass: 'text-truncate' },
            // { key: 'safe', label: 'Safe', sortable: false, thStyle: 'width: 35%;', tdClass: 'text-truncate' },
            // { key: 'factory', label: 'Factory', sortable: false, thStyle: 'width: 35%;', tdClass: 'text-truncate' },
            // { key: 'chain', label: 'Chain', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
          ],

          safesFields: [
            { key: 'index', label: '#', sortable: false, thStyle: 'width: 7%;', tdClass: 'text-truncate' },
            { key: 'blockNumber', label: 'Block # / Log Index', sortable: false, thStyle: 'width: 13%;', tdClass: 'text-truncate' },
            { key: 'safe', label: 'Safe', sortable: false, thStyle: 'width: 35%;', tdClass: 'text-truncate' },
            { key: 'factory', label: 'Factory', sortable: false, thStyle: 'width: 35%;', tdClass: 'text-truncate' },
            { key: 'chain', label: 'Chain', sortable: false, thStyle: 'width: 10%;', tdClass: 'text-truncate' },
          ],

          db: {
            name: "gnosissafeexplorer088f",
            version: 1,
            schemaDefinition: {
              safeFactoryEvents: '[chainId+blockNumber+logIndex],safe,factory',
              safeEvents: '[chainId+blockNumber+logIndex],safe,eventType',
              cache: '&objectName',
            },
            updated: null,
          },
        },

        // --- COMPUTED ---
        computed: {

          factories() {
            const result = {};
            for (const [version, versionData] of Object.entries(SAFE_ADDRESSES)) {
              for (const [chainId, chainData] of Object.entries(versionData)) {
                for (const [contractName, address] of Object.entries(chainData)) {
                  if (contractName == "proxy_factory" || contractName == "safe_proxy_factory") {
                    result[address] = version;
                  }
                }
              }
            }
            return result;
          },

          safeContractNames() {
            const results = {};
            for (const [version, versionData] of Object.entries(SAFE_ADDRESSES)) {
              for (const [chainId, chainData] of Object.entries(versionData)) {
                for (const [contractName, address] of Object.entries(chainData)) {
                  // console.log(version + "/" + chainId + "/" + contractName + " => " + address);
                  results[address] = contractName + " v" + version + "/" + chainId + " " + address.substring(0, 8) + '...' + address.slice(-6);
                }
              }
            }
            return results;
          },

          modalSafeOwners() {
            const results = {};
            let i = 1;
            for (const owner of (this.modalSafe.info.owners || [])) {
              results[owner] = "Owner #" + i++;
            }
            return results;
          },

          modalSafeTxs() {
            // console.log(moment().format("HH:mm:ss") + " modalSafeTxs - this.modalSafe.events: " + JSON.stringify(this.modalSafe.events));
            const results = [];
            const collator = {};
            for (const [blockNumber, blockData] of Object.entries(this.modalSafe.events)) {
              for (const [txHash, txData] of Object.entries(blockData)) {
                for (const [logIndex, logData] of Object.entries(txData)) {
                  // console.log(blockNumber + "/" + txHash + "/" + logIndex + " => " + JSON.stringify(logData));
                  if (!(txHash in collator)) {
                    collator[txHash] = {
                      blockNumber,
                      txIndex: logData.txIndex,
                      tx: this.txData[this.chainId] && this.txData[this.chainId][txHash] && this.txData[this.chainId][txHash].tx || null,
                      txReceipt: this.txData[this.chainId] && this.txData[this.chainId][txHash] && this.txData[this.chainId][txHash].txReceipt || null,
                      events: {},
                    };
                  }
                  if (!(logIndex in collator[txHash].events)) {
                    collator[txHash].events[logIndex] = {
                      ...logData,
                    };
                  }
                }
              }
            }
            // console.log(moment().format("HH:mm:ss") + " modalSafeTxs - collator: " + JSON.stringify(collator, null, 2));
            for (const [txHash, txData] of Object.entries(collator)) {
              results.push({ txHash, ...txData });
            }
            return results;
          },
          filteredSortedModalSafeTxs() {
            const results = this.modalSafeTxs;
            if (this.settings.safeTxsTable.sortOption == 'blocknumberasc') {
              results.sort((a, b) => {
                if (a.blockNumber == b.blockNumber) {
                  return a.txIndex - b.txIndex;
                } else {
                  return a.blockNumber - b.blockNumber;
                }
              });
            } else if (this.settings.safeTxsTable.sortOption == 'blocknumberdsc') {
              results.sort((a, b) => {
                if (a.blockNumber == b.blockNumber) {
                  return b.txIndex - a.txIndex;
                } else {
                  return b.blockNumber - a.blockNumber;
                }
              });
            }
            return results;
          },
          pagedFilteredSortedModalSafeTxs() {
            const results = this.filteredSortedModalSafeTxs.slice((this.settings.safeTxsTable.currentPage - 1) * this.settings.safeTxsTable.pageSize, this.settings.safeTxsTable.currentPage * this.settings.safeTxsTable.pageSize);
            // console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedModalSafeTxs - results: " + JSON.stringify(results, null, 2).substring(0, 1000));
            return results;
          },

          // validSafes() {
          //   console.log(moment().format("HH:mm:ss") + " validSafes");
          //   const results = {};
          //   for (const [chainId, chainData] of Object.entries(this.safes)) {
          //     for (const [safeAddressIndex, safeData] of Object.entries(chainData)) {
          //       console.log(moment().format("HH:mm:ss") + " validSafes - " + safeAddressIndex + " => " + JSON.stringify(safeData));
          //       // results.push({ chainId, safeAddressIndex, ...safeData });
          //       results[this.indexToAddress[safeAddressIndex]] = safeAddressIndex;
          //     }
          //   }
          //   return results;
          // },

          allSafes() {
            // console.log(moment().format("HH:mm:ss") + " allSafes");
            const results = [];
            for (const [chainId, chainData] of Object.entries(this.safes)) {
              for (const [safeAddressIndex, safeData] of Object.entries(chainData)) {
                results.push({ chainId, safeAddressIndex, ...safeData });
              }
            }
            return results;
          },

          filteredSortedSafes() {
            // console.log(moment().format("HH:mm:ss") + " filteredSortedSafes - filter: " + this.settings.safesTable.filter);
            const results = [];
            // const filter = this.settings.safesTable.filter != null && this.settings.safesTable.filter.length > 0 ? this.settings.safesTable.filter : null;
            // let regex = null;
            // if (this.settings.safesTable.filter != null && this.settings.safesTable.filter.length > 0) {
            //   try {
            //     regex = new RegExp(this.settings.safesTable.filter.toLowerCase());
            //   } catch (e) {
            //     console.log(moment().format("HH:mm:ss") + " filteredSortedSafes - regex error: " + e.message);
            //     regex = new RegExp(/thequickbrowndogjumpsoverthelazyfox/, 'i');
            //   }
            // }
            for (const safe of this.allSafes) {
              // let include = true;
              // if (regex) {
              //   if (!(regex.test(this.indexToAddress[safe.safeAddressIndex].toLowerCase()))) {
              //     include = false;
              //   }
              // }
              // if (filter) {
              //   const safeAddress = this.indexToAddress[safe.safeAddressIndex];
              //   if (safeAddress.indexOf(filter) < 0) {
              //     include = false;
              //   }
              // }
              // if (include) {
                results.push(safe);
              // }
            }
            if (this.settings.safesTable.sortOption == 'blocknumberasc') {
              results.sort((a, b) => {
                if (a.blockNumber == b.blockNumber) {
                  return a.logIndex - b.logIndex;
                } else {
                  return a.blockNumber - b.blockNumber;
                }
              });
            } else if (this.settings.safesTable.sortOption == 'blocknumberdsc') {
              results.sort((a, b) => {
                if (a.blockNumber == b.blockNumber) {
                  return b.logIndex - a.logIndex;
                } else {
                  return b.blockNumber - a.blockNumber;
                }
              });
            }
            return results;
          },
          pagedFilteredSortedSafes() {
            const results = this.filteredSortedSafes.slice((this.settings.safesTable.currentPage - 1) * this.settings.safesTable.pageSize, this.settings.safesTable.currentPage * this.settings.safesTable.pageSize);
            // console.log(moment().format("HH:mm:ss") + " pagedFilteredSortedSafes - results: " + JSON.stringify(results, null, 2));
            return results;
          },
        },

        // --- METHODS ---
        methods: {

          async safesRowSelected(item) {
            if (item && item.length > 0) {
              console.log(moment().format("HH:mm:ss") + " safesRowSelected - item: " + JSON.stringify(item, null, 2));
              this.modalSafe.chainId = item[0].chainId;
              this.modalSafe.safeAddressIndex = item[0].safeAddressIndex;
              this.modalSafe.safe = this.indexToAddress[item[0].safeAddressIndex];
              this.modalSafe.blockNumber = item[0].blockNumber;
              this.modalSafe.logIndex = item[0].logIndex;
              this.modalSafe.txHashIndex = item[0].txHashIndex;
              this.modalSafe.factoryAddressIndex = item[0].factoryAddressIndex;
              this.modalSafe.factory = this.indexToAddress[item[0].factoryAddressIndex];
              this.$bvModal.show('modal-safe');
              this.$refs.safesTable.clearSelected();
              this.retrieveModalSafeEvents();
            }
          },

          async processSafeEvents141(logs, factoryVersion, safeVersion) {
            console.log(moment().format("HH:mm:ss") + " processSafeEvents141 - factoryVersion: " + factoryVersion + ", safeVersion:" + safeVersion);

            const safeABI = safeVersion && ABIS[safeVersion] && ABIS[safeVersion].gnosis_safe || ABIS["1.3.0"].gnosis_safe;
            // console.log(moment().format("HH:mm:ss") + " processSafeEvents141 - safeABI: " + JSON.stringify(safeABI));
            const safeInterface = new ethers.utils.Interface(safeABI);
            for (const log of logs) {
              if (!log.removed) {
                // console.log(moment().format("HH:mm:ss") + " processSafeEvents141 - log: " + JSON.stringify(log, null, 2));
                // 0x141df868a6331af528e38c83b7aa03edc19be66e37ae67f9285bf4f8e3c6a1a8
                // event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);
                // event ApproveHash(bytes32 indexed approvedHash, address indexed owner);
                // event SignMsg(bytes32 indexed msgHash);
                // event ExecutionFailure(bytes32 indexed txHash, uint256 payment);
                // 0x442e715f626346e8c54381002da614f62bee8d27386535b2521ec8540898556e
                // event ExecutionSuccess(bytes32 indexed txHash, uint256 payment);

                // FallbackManager.sol 3/16
                // event ChangedFallbackHandler(address indexed handler);

                // GuardManager.sol 4/16
                // event ChangedGuard(address indexed guard);

                // ModuleManager.sol 5/16
                // event EnabledModule(address indexed module);
                // event DisabledModule(address indexed module);
                // event ExecutionFromModuleSuccess(address indexed module);
                // event ExecutionFromModuleFailure(address indexed module);

                // OwnerManager.sol 6/16
                // 0x9465fa0c962cc76958e6373a993326400c1c94f8be2fe3a952adfa7f60b2ea26
                // event AddedOwner(address indexed owner);
                // 0xf8d49fc529812e9a7c5c50e69c20f0dccc0db8fa95c98bc58cc9a4f1c1299eaf
                // event RemovedOwner(address indexed owner);
                // event ChangedThreshold(uint256 threshold);

                // NativeCurrencyPaymentFallback.sol 8/16
                // 0x3d0ce9bfc3ed7d6862dbb28b2dea94561fe714a1b4d019aa8af39730d1ad7c3d
                // event SafeReceived(address indexed sender, uint256 value);

                const event = {};
                try {
                  const logData = safeInterface.parseLog(log);
                  // console.log(moment().format("HH:mm:ss") + " processSafeEvents - logData: " + JSON.stringify(logData, null, 2));
                  event.name = logData.eventFragment.name;
                  // TODO: Complete extracting all event types
                  if (event.name == "SafeSetup") {
                    // event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);
                    const [initiator, owners, threshold, initializer, fallbackHandler] = logData.args;
                    event.initiator = initiator;
                    event.owners = owners;
                    event.threshold = parseInt(threshold);
                    event.initializer = initializer;
                    event.fallbackHandler = fallbackHandler;
                  } else if (event.name == "SafeReceived") {
                    // event SafeReceived(address indexed sender, uint256 value);
                    const [sender, value] = logData.args;
                    event.sender = sender;
                    event.value = ethers.BigNumber.from(value).toString();
                  } else if (event.name == "ExecutionSuccess") {
                    // event ExecutionSuccess(bytes32 indexed txHash, uint256 payment);
                    const [txHash, payment] = logData.args;
                    event.txHash = txHash;
                    event.payment = ethers.BigNumber.from(payment).toString();
                  } else {
                    event.parameterNames = logData.eventFragment.inputs.map(({ name, type }) => ({ name, type }));
                    event.parameters = logData.args;
                  }
                } catch (e) {
                  event.name = "Unknown signature: " + log.topics[0];
                }

                if (!(log.blockNumber in this.modalSafe.events)) {
                  Vue.set(this.modalSafe.events, log.blockNumber, {});
                }
                if (!(log.logIndex in this.modalSafe.events[log.blockNumber])) {
                  Vue.set(this.modalSafe.events[log.blockNumber], log.transactionHash, {});
                }
                if (!(log.logIndex in this.modalSafe.events[log.blockNumber][log.transactionHash])) {
                  Vue.set(this.modalSafe.events[log.blockNumber][log.transactionHash], log.logIndex, {
                    address: log.address,
                    transactionHash: log.transactionHash,
                    txIndex: log.transactionIndex,
                    ...event,
                    data: log.data,
                    topics: log.topics,
                    // parameterNames,
                    // parameters,
                  });
                }
              }
            }
          },

          async processSafeTxData(provider, chainId, factoryVersion, safeVersion) {
            console.log(moment().format("HH:mm:ss") + " processSafeTxData - chainId: " + chainId + ", factoryVersion: " + factoryVersion + ", safeVersion:" + safeVersion);
            const db = new Dexie(this.db.name);
            db.version(this.db.version).stores(this.db.schemaDefinition);
            let timestamps = {};
            const timestampsDataItems = await db.cache.where("objectName").equals("timestamps").toArray();
            if (timestampsDataItems.length == 1) {
              timestamps = timestampsDataItems[0].object;
            }
            if (!(chainId in timestamps)) {
              timestamps[chainId] = {};
            }
            // console.log(moment().format("HH:mm:ss") + " processSafeTxData - timestamps 1: " + JSON.stringify(timestamps, null, 2));
            let txData = {};
            const txDataItems = await db.cache.where("objectName").equals("txData_" + this.modalSafe.safe).toArray();
            if (txDataItems.length == 1) {
              txData = txDataItems[0].object;
            }
            if (!(chainId in txData)) {
              txData[chainId] = {};
            }
            // console.log(moment().format("HH:mm:ss") + " processSafeTxData - txData 1: " + JSON.stringify(txData, null, 2));
            const txHashes = {};
            for (const [blockNumber, blockData] of Object.entries(this.modalSafe.events)) {
              for (const [txHash, txData] of Object.entries(blockData)) {
                if (!(txHash in txHashes)) {
                  txHashes[txHash] = blockNumber;
                }
              }
            }
            // console.log(moment().format("HH:mm:ss") + " processSafeTxData - txHashes: " + JSON.stringify(txHashes));
            for (const [txHash, blockNumber] of Object.entries(txHashes)) {
              // console.log(moment().format("HH:mm:ss") + " processSafeTxData - txHash: " + txHash + ", blockNumber: " + blockNumber);
              if (!(blockNumber in timestamps[chainId])) {
                const block = await provider.getBlock(parseInt(blockNumber));
                const timestamp = block.timestamp;
                // console.log(moment().format("HH:mm:ss") + " processSafeTxData - blockNumber: " + blockNumber + ", timestamp: " + timestamp + " " + moment.unix(timestamp).format("YYYY-MM-DD HH:mm:ss"));
                timestamps[chainId][blockNumber] = timestamp;
              }
              if (!(txHash in txData[chainId])) {
                txData[chainId][txHash] = {
                  tx: null,
                  txReceipt: null,
                };
              }
              if (!txData[chainId][txHash].tx) {
                const tx = await provider.getTransaction(txHash);
                // console.log(moment().format("HH:mm:ss") + " processSafeTxData - tx: " + JSON.stringify(tx));
                txData[chainId][txHash].tx = {
                  blockNumber: tx.blockNumber,
                  type: tx.type || null,
                  txIndex: tx.transactionIndex,
                  from: tx.from,
                  nonce: parseInt(tx.nonce),
                  to: tx.to,
                  data: tx.data,
                  gasPrice: ethers.BigNumber.from(tx.gasPrice).toString(),
                  maxPriorityFeePerGas: tx.maxPriorityFeePerGas && ethers.BigNumber.from(tx.maxPriorityFeePerGas).toString() || null,
                  gasLimit: parseInt(tx.gasLimit),
                }
              }
              if (!txData[chainId][txHash].txReceipt) {
                const txReceipt = await provider.getTransactionReceipt(txHash);
                // console.log(moment().format("HH:mm:ss") + " processSafeTxData - txReceipt: " + JSON.stringify(txReceipt));
                txData[chainId][txHash].txReceipt = {
                  type: parseInt(txReceipt.type),
                  txIndex: txReceipt.transactionIndex,
                  from: txReceipt.from,
                  to: txReceipt.to,
                  contractAddress: txReceipt.contractAddress,
                  gasUsed: parseInt(txReceipt.gasUsed),
                  cumulativeGasUsed: parseInt(txReceipt.cumulativeGasUsed),
                  effectiveGasPrice: txReceipt.effectiveGasPrice && parseInt(txReceipt.effectiveGasPrice) || null,
                  status: parseInt(txReceipt.status),
                  logs: txReceipt.logs,
                }
              }

            }
            // console.log(moment().format("HH:mm:ss") + " processSafeTxData - timestamps 2: " + JSON.stringify(timestamps, null, 2));
            await db.cache.put({ objectName: "timestamps", object: timestamps }).then (function() {
            }).catch(function(error) {
              console.log("error: " + error);
            });
            // console.log(moment().format("HH:mm:ss") + " processSafeTxData - txData 1: " + JSON.stringify(txData, null, 2));
            await db.cache.put({ objectName: "txData_" + this.modalSafe.safe, object: txData }).then (function() {
            }).catch(function(error) {
              console.log("error: " + error);
            });
            Vue.set(this, "txData", txData);
            console.log(moment().format("HH:mm:ss") + " processSafeTxData - end");
          },

          // Safe
          // 1.1.1 0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F
          // 1.3.0 0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552
          // 1.4.1 0x41675C099F32341bf84BFc5382aF534df5C7461a
          // TODO 1.2.0 0x6851D6fDFAfD08c0295C392436245E5bc78B0185
          async retrieveModalSafeEvents() {
            console.log(moment().format("HH:mm:ss") + " retrieveModalSafeEvents - this.modalSafe: " + JSON.stringify(this.modalSafe).substring(0, 1000));
            const factoryVersion = this.factories[this.modalSafe.factory] || null;
            // console.log(moment().format("HH:mm:ss") + " retrieveModalSafeEvents - factoryVersion: " + factoryVersion);
            let factoryABI = ABIS[factoryVersion] && ABIS[factoryVersion].gnosis_safe || null;
            // console.log(moment().format("HH:mm:ss") + " retrieveModalSafeEvents - factoryABI: " + JSON.stringify(factoryABI));
            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const network = await provider.getNetwork();
            const chainId = network.chainId;
            localStorage.gnosisSafeExplorerChainId = chainId;
            const block = await provider.getBlock();
            const latestBlockNumber = block && block.number || null;
            // console.log(moment().format("HH:mm:ss") + " retrieveModalSafeEvents - latestBlockNumber: " + latestBlockNumber);

            const allSafesAbi = [
              "function VERSION() public view returns (string)",
              "function getOwners() public view returns (address[] memory)",
              "function getThreshold() public view returns (uint256)",
              "function nonce() public view returns (uint256)",
              "function getStorageAt(uint256 offset, uint256 length) public view returns (bytes memory)",
            ];
            const allSafesContract = new ethers.Contract(this.modalSafe.safe, allSafesAbi, provider);
            let safeVersion = null;
            try {
              safeVersion = await allSafesContract.VERSION();
              console.log(moment().format("HH:mm:ss") + " retrieveModalSafeEvents - safeVersion: " + safeVersion);
            } catch (e) {
              console.error(moment().format("HH:mm:ss") + " retrieveModalSafeEvents - safeVersion - error: " + e.message);
            }
            Vue.set(this.modalSafe.info, 'factoryVersion', factoryVersion);
            Vue.set(this.modalSafe.info, 'safeVersion', safeVersion);

            let implementation = null;
            try {
              implementation = ethers.utils.getAddress('0x' + (await allSafesContract.getStorageAt(0, 1)).substring(26, 66));
              console.log(moment().format("HH:mm:ss") + " retrieveModalSafeEvents - implementation: " + JSON.stringify(implementation));
            } catch (e) {
              console.error(moment().format("HH:mm:ss") + " retrieveModalSafeEvents - implementation - error: " + e.message);
            }
            Vue.set(this.modalSafe.info, 'implementation', implementation);


            let owners = null;
            try {
              owners = await allSafesContract.getOwners();
              console.log(moment().format("HH:mm:ss") + " retrieveModalSafeEvents - owners: " + JSON.stringify(owners));
            } catch (e) {
              console.error(moment().format("HH:mm:ss") + " retrieveModalSafeEvents - owners - error: " + e.message);
            }
            Vue.set(this.modalSafe.info, 'owners', owners);
            let threshold = null;
            try {
              threshold = await allSafesContract.getThreshold();
              console.log(moment().format("HH:mm:ss") + " retrieveModalSafeEvents - threshold: " + parseInt(threshold));
            } catch (e) {
              console.error(moment().format("HH:mm:ss") + " retrieveModalSafeEvents - threshold - error: " + e.message);
            }
            Vue.set(this.modalSafe.info, 'threshold', parseInt(threshold));
            let nonce = null;
            try {
              nonce = await allSafesContract.nonce();
              console.log(moment().format("HH:mm:ss") + " retrieveModalSafeEvents - nonce: " + parseInt(nonce));
            } catch (e) {
              console.error(moment().format("HH:mm:ss") + " retrieveModalSafeEvents - nonce - error: " + e.message);
            }
            Vue.set(this.modalSafe.info, 'nonce', parseInt(nonce));

            // TODO: 1.1.1 and 1.3.0
            // if (safeVersion == "1.4.1") {
              const logs = await provider.getLogs({
                address: this.modalSafe.safe,
                fromBlock: 0,
                toBlock: latestBlockNumber,
                topics: null,
              });
              // console.log(moment().format("HH:mm:ss") + " retrieveModalSafeEvents - logs: " + JSON.stringify(logs));
              await this.processSafeEvents141(logs, factoryVersion, safeVersion);
              await this.processSafeTxData(provider, chainId, factoryVersion, safeVersion);
            // }
          },

          async loadCurrentData() {
            console.log(moment().format("HH:mm:ss") + " loadCurrentData - this.settings.safesTable.filter: " + this.settings.safesTable.filter);
            const DB_PROCESSING_BATCH_SIZE = 50000;
            const db = new Dexie(this.db.name);
            db.version(this.db.version).stores(this.db.schemaDefinition);
            for (const name of ['indexToAddress', 'indexToTxHash', 'timestamps']) {
              const dataItems = await db.cache.where("objectName").equals(name).toArray();
              if (dataItems.length == 1) {
                Vue.set(this, name, dataItems[0].object);
              }
            }
            const addressToIndex = {};
            for (const [index, address] of this.indexToAddress.entries()) {
              addressToIndex[address] = index;
            }
            Vue.set(this, 'addressToIndex', addressToIndex);
            const txHashToIndex = {};
            for (const [index, address] of this.indexToTxHash.entries()) {
              txHashToIndex[address] = index;
            }
            Vue.set(this, 'txHashToIndex', txHashToIndex);
            let rows = 0;
            let done = false;
            const safes = {};
            do {
              let data;
              if (this.settings.safesTable.filter && this.settings.safesTable.filter.length > 2) {
                data = await db.safeFactoryEvents.where('safe').startsWithIgnoreCase(this.settings.safesTable.filter).offset(rows).limit(DB_PROCESSING_BATCH_SIZE).toArray();
              } else {
                data = await db.safeFactoryEvents.where('[chainId+blockNumber+logIndex]').between([Dexie.minKey, Dexie.minKey, Dexie.minKey],[Dexie.maxKey, Dexie.maxKey, Dexie.maxKey]).offset(rows).limit(DB_PROCESSING_BATCH_SIZE).toArray();
              }
              console.log(moment().format("HH:mm:ss") + " loadCurrentData - data.length: " + data.length + ", first[0..9]: " + JSON.stringify(data.slice(0, 10).map(e => e.blockNumber + '.' + e.logIndex )));
              for (const item of data) {
                if (!(item.chainId in safes)) {
                  safes[item.chainId] = {};
                }
                if (!(item.safeAddressIndex in safes[item.chainId])) {
                  safes[item.chainId][item.safeAddressIndex] = {
                    blockNumber: item.blockNumber,
                    logIndex: item.logIndex,
                    txHashIndex: item.txHashIndex,
                    factoryAddressIndex: item.factoryAddressIndex,
                  };
                }
              }
              rows = parseInt(rows) + data.length;
              done = data.length < DB_PROCESSING_BATCH_SIZE;
            } while (!done);
            // console.log(moment().format("HH:mm:ss") + " loadCurrentData - safes: " + JSON.stringify(safes));
            Vue.set(this, 'safes', safes);
            db.close();
          },

          async retrieveSafeFactoryEvents() {
            async function processLogs(fromBlock, toBlock, logs) {
              console.log(moment().format("HH:mm:ss") + " retrieveSafeFactoryEvents - processLogs: " + fromBlock + ", toBlock: " + toBlock);
              const records = [];
              for (const log of logs) {
                if (!log.removed) {
                  if (log.address in factoryAddresses) {
                    // console.log(moment().format("HH:mm:ss") + " retrieveSafeFactoryEvents - log: " + JSON.stringify(log));
                    let safeAddress = null;
                    let implementationAddress = null;
                    if (log.address == "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B" || log.address == "0x12302fE9c02ff50939BaAaaf415fc226C078613C") {
                      // 1.1.1 event ProxyCreation(Proxy proxy)
                      safeAddress = ethers.utils.getAddress('0x' + log.data.substring(26, 66));
                      implementationAddress = "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F";
                    } else if (log.address == "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2") {
                      // '0x4f51faf6c4561ff95f067657e43439f0f856d97c04d9ec9070a6199ad418e235', // 1.3.0 event ProxyCreation(GnosisSafeProxy proxy, address singleton);
                      safeAddress = ethers.utils.getAddress('0x' + log.data.substring(26, 66));
                      implementationAddress = ethers.utils.getAddress('0x' + log.data.substring(90, 130));
                    } else {
                      // '0x4f51faf6c4561ff95f067657e43439f0f856d97c04d9ec9070a6199ad418e235', // 1.4.1 event ProxyCreation(SafeProxy indexed proxy, address singleton);
                      safeAddress = ethers.utils.getAddress('0x' + log.topics[1].substring(26, 66));
                      implementationAddress = ethers.utils.getAddress('0x' + log.data.substring(26, 66));
                    }
                    if (!(safeAddress in addressToIndex)) {
                      addressToIndex[safeAddress] = indexToAddress.length;
                      indexToAddress.push(safeAddress);
                    }
                    const safeAddressIndex = addressToIndex[safeAddress];
                    if (!(implementationAddress in addressToIndex)) {
                      addressToIndex[implementationAddress] = indexToAddress.length;
                      indexToAddress.push(implementationAddress);
                    }
                    const implementationAddressIndex = addressToIndex[implementationAddress];
                    if (!(log.transactionHash in txHashToIndex)) {
                      txHashToIndex[log.transactionHash] = indexToTxHash.length;
                      indexToTxHash.push(log.transactionHash);
                    }
                    const txHashIndex = txHashToIndex[log.transactionHash];
                    records.push({
                      chainId,
                      blockNumber: parseInt(log.blockNumber),
                      logIndex: parseInt(log.logIndex),
                      txIndex: parseInt(log.transactionIndex),
                      txHashIndex,
                      txHash: log.transactionHash,
                      safeAddressIndex,
                      safe: safeAddress,
                      factoryAddressIndex: addressToIndex[log.address],
                      factory: log.address,
                    });
                  } else {
                    if (log.topics[0] == "0x141df868a6331af528e38c83b7aa03edc19be66e37ae67f9285bf4f8e3c6a1a8") {
                      // '0x141df868a6331af528e38c83b7aa03edc19be66e37ae67f9285bf4f8e3c6a1a8',
                      // event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);
                      console.log(moment().format("HH:mm:ss") + " retrieveSafeFactoryEvents - log - SafeSetup: " + JSON.stringify(log));
                      try {
                        const logData = safeInterface141.parseLog(log);
                        console.log(moment().format("HH:mm:ss") + " retrieveSafeFactoryEvents - log - SafeSetup: " + JSON.stringify(logData));
                      } catch (e) {
                        console.log("error: " + e.message);
                      }
                    }
                  }
                }
              }
              if (records.length) {
                await db.safeFactoryEvents.bulkAdd(records).then(function(lastKey) {
                  // console.log(moment().format("HH:mm:ss") + " retrieveSafeFactoryEvents - bulkAdd lastKey: " + JSON.stringify(lastKey));
                }).catch(Dexie.BulkError, function(e) {
                  console.log(moment().format("HH:mm:ss") + " retrieveSafeFactoryEvents - bulkAdd e: " + JSON.stringify(e.failures, null, 2));
                });
              }
            }

            async function getLogsFromRange(fromBlock, toBlock) {
              console.log(moment().format("HH:mm:ss") + " retrieveSafeFactoryEvents - getLogsFromRange: " + fromBlock + ", toBlock: " + toBlock);
              try {
                const logs = await provider.getLogs({
                  // address: "0x12302fE9c02ff50939BaAaaf415fc226C078613C", // 1.0.0
                  // address: "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B", // 1.1.1
                  // address: "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2", // 1.3.0
                  // address: "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67", // 1.4.1
                  address: null,
                  fromBlock,
                  toBlock,
                  topics: [[
                      // 1.1.1 event ProxyCreation(Proxy proxy)
                      '0xa38789425dbeee0239e16ff2d2567e31720127fbc6430758c1a4efc6aef29f80',
                      // 1.3.0 event ProxyCreation(GnosisSafeProxy proxy, address singleton);
                      // 1.4.1 event ProxyCreation(SafeProxy indexed proxy, address singleton);
                      '0x4f51faf6c4561ff95f067657e43439f0f856d97c04d9ec9070a6199ad418e235',

                      // TODO
                      // 1.0.0 No SafeSetup
                      // 1.1.1
                      //  *** SafeSetup (index_topic_1 address initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler)
                      // 1.3.0 0x141df868a6331af528e38c83b7aa03edc19be66e37ae67f9285bf4f8e3c6a1a8
                      // event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);
                      // 1.4.1 0x141df868a6331af528e38c83b7aa03edc19be66e37ae67f9285bf4f8e3c6a1a8
                      // event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);
                      // '0x141df868a6331af528e38c83b7aa03edc19be66e37ae67f9285bf4f8e3c6a1a8',
                    ],
                  ],
                });
                await processLogs(fromBlock, toBlock, logs);
                t.sync.completed = toBlock;
              } catch (e) {
                console.error(moment().format("HH:mm:ss") + " retrieveSafeFactoryEvents - Error: " + e.message);
                const mid = parseInt((fromBlock + toBlock) / 2);
                await getLogsFromRange(fromBlock, mid);
                await getLogsFromRange(parseInt(mid) + 1, toBlock);
              }
            }

            const t = this;
            const db = new Dexie(this.db.name);
            db.version(this.db.version).stores(this.db.schemaDefinition);

            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const network = await provider.getNetwork();
            const chainId = network.chainId;
            localStorage.gnosisSafeExplorerChainId = chainId;
            const block = await provider.getBlock();
            const latestBlockNumber = block && block.number || null;
            console.log(moment().format("HH:mm:ss") + " retrieveSafeFactoryEvents - latestBlockNumber: " + latestBlockNumber);
            this.sync.section = "Syncing";
            this.sync.total = latestBlockNumber;
            this.sync.completed = 0;
            const factoryAddress = SAFE_ADDRESSES["1.1.1"] && SAFE_ADDRESSES["1.1.1"]["1"] && SAFE_ADDRESSES["1.1.1"]["1"]["proxy_factory"] || null;
            console.log(moment().format("HH:mm:ss") + " retrieveSafeFactoryEvents - factoryAddress: " + JSON.stringify(factoryAddress));
            const factoryABI = ABIS["1.1.1"] && ABIS["1.1.1"]["proxy_factory"] || null;
            const safeABI141 = ABIS["1.4.1"].gnosis_safe;
            console.log(moment().format("HH:mm:ss") + " retrieveSafeFactoryEvents - safeABI141: " + JSON.stringify(safeABI141));
            const safeInterface141 = new ethers.utils.Interface(safeABI141);

            let indexToAddress = [];
            let addressToIndex = {};
            const indexToAddressDataItems = await db.cache.where("objectName").equals("indexToAddress").toArray();
            if (indexToAddressDataItems.length == 1) {
              indexToAddress = indexToAddressDataItems[0].object;
              for (const [index, address] of indexToAddress.entries()) {
                addressToIndex[address] = index;
              }
            }
            let indexToTxHash = [];
            let txHashToIndex = {};
            const indexToTxHashDataItems = await db.cache.where("objectName").equals("indexToTxHash").toArray();
            if (indexToTxHashDataItems.length == 1) {
              indexToTxHash = indexToTxHashDataItems[0].object;
              for (const [index, txHash] of indexToTxHash.entries()) {
                txHashToIndex[txHash] = index;
              }
            }
            if (!(factoryAddress in addressToIndex)) {
              addressToIndex[factoryAddress] = indexToAddress.length;
              indexToAddress.push(factoryAddress);
            }
            const factoryAddresses = this.factories;
            for (const factoryAddress in factoryAddresses) {
              if (!(factoryAddress in addressToIndex)) {
                addressToIndex[factoryAddress] = indexToAddress.length;
                indexToAddress.push(factoryAddress);
              }
            }
            console.log(moment().format("HH:mm:ss") + " retrieveSafeFactoryEvents - factoryAddresses: " + JSON.stringify(factoryAddresses));

            const latest = await db.safeFactoryEvents.where('[chainId+blockNumber+logIndex]').between([chainId, Dexie.minKey, Dexie.minKey],[chainId, Dexie.maxKey, Dexie.maxKey]).last();
            console.log(moment().format("HH:mm:ss") + " retrieveSafeFactoryEvents - latest: " + JSON.stringify(latest));
            // TODO: TEST
            // const startBlock = latest ? parseInt(latest.blockNumber) + 1: latestBlockNumber - 100000;
            const startBlock = latest ? parseInt(latest.blockNumber) + 1: 0;
            this.sync.completed = startBlock;
            console.log(moment().format("HH:mm:ss") + " retrieveSafeFactoryEvents - startBlock: " + startBlock);
            await getLogsFromRange(startBlock, latestBlockNumber);

            Vue.set(this, "addressToIndex", addressToIndex);
            Vue.set(this, "indexToAddress", indexToAddress);
            await db.cache.put({ objectName: "indexToAddress", object: indexToAddress }).then (function() {
            }).catch(function(error) {
              console.log("error: " + error);
            });
            Vue.set(this, "txHashToIndex", txHashToIndex);
            Vue.set(this, "indexToTxHash", indexToTxHash);
            await db.cache.put({ objectName: "indexToTxHash", object: indexToTxHash }).then (function() {
            }).catch(function(error) {
              console.log("error: " + error);
            });
            await this.loadCurrentData();
            this.sync.section = null;
          },

          async retrieveSafeEvents() {
            const LOGTOPICS_BY_LENGTH = {
              // 1.3.0 event ExecutionFailure(bytes32 txHash, uint256 payment)
              // 1.4.1 event ExecutionFailure(bytes32 indexed txHash, uint256 payment)
              // '0x23428b18acfb3ea64b08dc0c1d296ea9c09702c09083ca5272e64d115b687d23',
              '0x23428b18acfb3ea64b08dc0c1d296ea9c09702c09083ca5272e64d115b687d23': {
                1: 130,
                2: 141,
              },
              // 1.3.0 event ExecutionSuccess(bytes32 txHash, uint256 payment)
              // 1.4.1 event ExecutionSuccess(bytes32 indexed txHash, uint256 payment)
              // '0x442e715f626346e8c54381002da614f62bee8d27386535b2521ec8540898556e',
              '0x442e715f626346e8c54381002da614f62bee8d27386535b2521ec8540898556e': {
                1: 130,
                2: 141,
              },
            };

            async function processLogs(fromBlock, toBlock, logs) {
              console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - processLogs: " + fromBlock + ", toBlock: " + toBlock);
              const records = [];
              for (const log of logs) {
                if (!log.removed) {
                  console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - log: " + JSON.stringify(log));
                  let event = null;
                  let abiVersion = 141;
                  if (log.topics[0] in LOGTOPICS_BY_LENGTH) {
                    if (log.topics.length in LOGTOPICS_BY_LENGTH[log.topics[0]]) {
                      abiVersion = LOGTOPICS_BY_LENGTH[log.topics[0]][log.topics.length];
                    }
                  }
                  console.log("abiVersion: " + abiVersion);


                  if (log.topics[0] == "0x141df868a6331af528e38c83b7aa03edc19be66e37ae67f9285bf4f8e3c6a1a8" ||
                      log.topics[0] == "0xf2a0eb156472d1440255b0d7c1e19cc07115d1051fe605b0dce69acfec884d9c" ||
                      log.topics[0] == "0xe7f4675038f4f6034dfcbbb24c4dc08e4ebf10eb9d257d3d02c0f38d122ac6e4") {
                      // 1.3.0 & 1.4.1 event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);
                      // 1.3.0 & 1.4.1 event ApproveHash(bytes32 indexed approvedHash, address indexed owner);
                      // 1.3.0 & 1.4.1 event SignMsg(bytes32 indexed msgHash)
                    const logData = safeInterface141.parseLog(log);
                    console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - logData SafeSetup: " + JSON.stringify(logData));
                    event = {
                      name: logData.eventFragment.name,
                    };

                  } else if (log.topics[0] == "0x23428b18acfb3ea64b08dc0c1d296ea9c09702c09083ca5272e64d115b687d23" ||
                             log.topics[0] == "0x442e715f626346e8c54381002da614f62bee8d27386535b2521ec8540898556e") {
                      if (log.topics.length == 1) {
                        // 1.3.0 event ExecutionFailure(bytes32 txHash, uint256 payment)
                        // 1.3.0 event ExecutionSuccess(bytes32 txHash, uint256 payment)
                        // const logData = safeInterface130.parseLog(log);
                        // console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - logData 1.3.0: " + JSON.stringify(logData));

                      } else {
                        // 1.4.1 event ExecutionFailure(bytes32 indexed txHash, uint256 payment)
                        // 1.4.1 event ExecutionSuccess(bytes32 indexed txHash, uint256 payment)
                        // const logData = safeInterface141.parseLog(log);
                        // console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - logData 1.4.1: " + JSON.stringify(logData));
                      }

                  } else {
                    // if (log.topics[0] == "0x141df868a6331af528e38c83b7aa03edc19be66e37ae67f9285bf4f8e3c6a1a8") {
                      // '0x141df868a6331af528e38c83b7aa03edc19be66e37ae67f9285bf4f8e3c6a1a8',
                      // event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);
                      // console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - log - SafeSetup: " + JSON.stringify(log));
                      try {
                        const logData = safeInterface141.parseLog(log);
                        console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - logData: " + JSON.stringify(logData));
                        event = {
                          name: logData.eventFragment.name,
                        };
                      } catch (e) {
                        console.error(moment().format("HH:mm:ss") + " retrieveSafeEvents - error: " + e.message);
                      }
                    // }
                  }

                  if (event) {
                    records.push({
                    //   chainId,
                    //   blockNumber: parseInt(log.blockNumber),
                    //   logIndex: parseInt(log.logIndex),
                    //   txIndex: parseInt(log.transactionIndex),
                    //   txHashIndex,
                    //   txHash: log.transactionHash,
                    //   safeAddressIndex,
                    //   safe: safeAddress,
                    //   factoryAddressIndex: addressToIndex[log.address],
                      ...event,
                    });
                  }

                  // if (log.address in factoryAddresses) {
                  //   let safeAddress = null;
                  //   let implementationAddress = null;
                  //   if (log.address == "0x76E2cFc1F5Fa8F6a5b3fC4c8F4788F0116861F9B" || log.address == "0x12302fE9c02ff50939BaAaaf415fc226C078613C") {
                  //     // 1.1.1 event ProxyCreation(Proxy proxy)
                  //     safeAddress = ethers.utils.getAddress('0x' + log.data.substring(26, 66));
                  //     implementationAddress = "0x34CfAC646f301356fAa8B21e94227e3583Fe3F5F";
                  //   } else if (log.address == "0xa6B71E26C5e0845f74c812102Ca7114b6a896AB2") {
                  //     // '0x4f51faf6c4561ff95f067657e43439f0f856d97c04d9ec9070a6199ad418e235', // 1.3.0 event ProxyCreation(GnosisSafeProxy proxy, address singleton);
                  //     safeAddress = ethers.utils.getAddress('0x' + log.data.substring(26, 66));
                  //     implementationAddress = ethers.utils.getAddress('0x' + log.data.substring(90, 130));
                  //   } else {
                  //     // '0x4f51faf6c4561ff95f067657e43439f0f856d97c04d9ec9070a6199ad418e235', // 1.4.1 event ProxyCreation(SafeProxy indexed proxy, address singleton);
                  //     safeAddress = ethers.utils.getAddress('0x' + log.topics[1].substring(26, 66));
                  //     implementationAddress = ethers.utils.getAddress('0x' + log.data.substring(26, 66));
                  //   }
                  //   if (!(safeAddress in addressToIndex)) {
                  //     addressToIndex[safeAddress] = indexToAddress.length;
                  //     indexToAddress.push(safeAddress);
                  //   }
                  //   const safeAddressIndex = addressToIndex[safeAddress];
                  //   if (!(implementationAddress in addressToIndex)) {
                  //     addressToIndex[implementationAddress] = indexToAddress.length;
                  //     indexToAddress.push(implementationAddress);
                  //   }
                  //   const implementationAddressIndex = addressToIndex[implementationAddress];
                  //   if (!(log.transactionHash in txHashToIndex)) {
                  //     txHashToIndex[log.transactionHash] = indexToTxHash.length;
                  //     indexToTxHash.push(log.transactionHash);
                  //   }
                  //   const txHashIndex = txHashToIndex[log.transactionHash];
                  //   records.push({
                  //     chainId,
                  //     blockNumber: parseInt(log.blockNumber),
                  //     logIndex: parseInt(log.logIndex),
                  //     txIndex: parseInt(log.transactionIndex),
                  //     txHashIndex,
                  //     txHash: log.transactionHash,
                  //     safeAddressIndex,
                  //     safe: safeAddress,
                  //     factoryAddressIndex: addressToIndex[log.address],
                  //     factory: log.address,
                  //   });
                  // } else {
                  //   if (log.topics[0] == "0x141df868a6331af528e38c83b7aa03edc19be66e37ae67f9285bf4f8e3c6a1a8") {
                  //     // '0x141df868a6331af528e38c83b7aa03edc19be66e37ae67f9285bf4f8e3c6a1a8',
                  //     // event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);
                  //     console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - log - SafeSetup: " + JSON.stringify(log));
                  //     try {
                  //       const logData = safeInterface141.parseLog(log);
                  //       console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - log - SafeSetup: " + JSON.stringify(logData));
                  //     } catch (e) {
                  //       console.log("error: " + e.message);
                  //     }
                  //   }
                  // }
                }
              }
              if (records.length) {
                console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - records: " + JSON.stringify(records));
                // await db.safeFactoryEvents.bulkAdd(records).then(function(lastKey) {
                //   // console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - bulkAdd lastKey: " + JSON.stringify(lastKey));
                // }).catch(Dexie.BulkError, function(e) {
                //   console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - bulkAdd e: " + JSON.stringify(e.failures, null, 2));
                // });
              }
            }

            async function getLogsFromRange(fromBlock, toBlock) {
              console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - getLogsFromRange: " + fromBlock + ", toBlock: " + toBlock);
              try {
                const logs = await provider.getLogs({
                  address: null,
                  fromBlock,
                  toBlock,
                  topics: [[
                      // 1.0.0 & 1.1.1 No SafeSetup
                      // 1.3.0 & 1.4.1 event SafeSetup(address indexed initiator, address[] owners, uint256 threshold, address initializer, address fallbackHandler);
                      // '0x141df868a6331af528e38c83b7aa03edc19be66e37ae67f9285bf4f8e3c6a1a8',
                      // 1.3.0 & 1.4.1 event ApproveHash(bytes32 indexed approvedHash, address indexed owner);
                      // '0xf2a0eb156472d1440255b0d7c1e19cc07115d1051fe605b0dce69acfec884d9c',
                      // 1.3.0 & 1.4.1 event SignMsg(bytes32 indexed msgHash)
                      // '0xe7f4675038f4f6034dfcbbb24c4dc08e4ebf10eb9d257d3d02c0f38d122ac6e4',
                      // TODO: Out of bounds error - check earlier version
                      // 1.3.0 event ExecutionFailure(bytes32 txHash, uint256 payment)
                      // 1.4.1 event ExecutionFailure(bytes32 indexed txHash, uint256 payment)
                      '0x23428b18acfb3ea64b08dc0c1d296ea9c09702c09083ca5272e64d115b687d23',
                      // TODO: Out of bounds error - check earlier version
                      // 1.3.0 event ExecutionSuccess(bytes32 txHash, uint256 payment)
                      // 1.4.1 event ExecutionSuccess(bytes32 indexed txHash, uint256 payment)
                      // '0x442e715f626346e8c54381002da614f62bee8d27386535b2521ec8540898556e',

                      // 1.3.0 event ChangedFallbackHandler(address handler)
                      // 1.4.1 event ChangedFallbackHandler(address indexed handler)
                      // '0x5ac6c46c93c8d0e53714ba3b53db3e7c046da994313d7ed0d192028bc7c228b0',

                      // TODO: Out of bounds error - check earlier version
                      // 1.3.0 event ChangedGuard(address guard)
                      // 1.4.1 event ChangedGuard(address indexed guard)
                      // '0x1151116914515bc0891ff9047a6cb32cf902546f83066499bcf8ba33d2353fa2',

                      // TODO: Out of bounds error - check earlier version
                      // 1.3.0 event EnabledModule(address module)
                      // 1.4.1 event EnabledModule(address indexed module)
                      // '0xecdf3a3effea5783a3c4c2140e677577666428d44ed9d474a0b3a4c9943f8440',
                      // TODO: Out of bounds error - check earlier version
                      // 1.3.0 event DisabledModule(address module)
                      // 1.4.1 event DisabledModule(address indexed module)
                      // '0xaab4fa2b463f581b2b32cb3b7e3b704b9ce37cc209b5fb4d77e593ace4054276',
                      // 1.3.0 & 1.4.1 event ExecutionFromModuleSuccess(address indexed module)
                      // '0x6895c13664aa4f67288b25d7a21d7aaa34916e355fb9b6fae0a139a9085becb8',
                      // 1.3.0 & 1.4.1 event ExecutionFromModuleFailure(address indexed module)
                      // '0xacd2c8702804128fdb0db2bb49f6d127dd0181c13fd45dbfe16de0930e2bd375',

                      // TODO: Out of bounds error - check earlier version
                      // 1.3.0 event AddedOwner(address owner)
                      // 1.4.1 event AddedOwner(address indexed owner)
                      // '0x9465fa0c962cc76958e6373a993326400c1c94f8be2fe3a952adfa7f60b2ea26',
                      // 1.3.0 event RemovedOwner(address owner)
                      // 1.4.1 event RemovedOwner(address indexed owner)
                      // '0xf8d49fc529812e9a7c5c50e69c20f0dccc0db8fa95c98bc58cc9a4f1c1299eaf',
                      // 1.3.0 & 1.4.1 event ChangedThreshold(uint256 threshold)
                      // '0x610f7ff2b304ae8903c3de74c60c6ab1f7d6226b3f52c5161905bb5ad4039c93',

                      // event SafeReceived(address indexed sender, uint256 value);
                      // '0x3d0ce9bfc3ed7d6862dbb28b2dea94561fe714a1b4d019aa8af39730d1ad7c3d',
                    ],
                  ],
                });
                await processLogs(fromBlock, toBlock, logs);
                // console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - logs: " + JSON.stringify(logs, null, 2));
                t.sync.completed = toBlock;
              } catch (e) {
                console.error(moment().format("HH:mm:ss") + " retrieveSafeEvents - Error: " + e.message);
                const mid = parseInt((fromBlock + toBlock) / 2);
                await getLogsFromRange(fromBlock, mid);
                await getLogsFromRange(parseInt(mid) + 1, toBlock);
              }
            }

            // const validSafes = this.validSafes;
            // console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - validSafes: " + JSON.stringify(validSafes));

            const t = this;
            const db = new Dexie(this.db.name);
            db.version(this.db.version).stores(this.db.schemaDefinition);

            const provider = new ethers.providers.Web3Provider(window.ethereum);
            const network = await provider.getNetwork();
            const chainId = network.chainId;
            localStorage.gnosisSafeExplorerChainId = chainId;
            const block = await provider.getBlock();
            const latestBlockNumber = block && block.number || null;
            console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - latestBlockNumber: " + latestBlockNumber);
            this.sync.section = "Syncing";
            this.sync.total = latestBlockNumber;
            this.sync.completed = 0;
            const factoryAddress = SAFE_ADDRESSES["1.1.1"] && SAFE_ADDRESSES["1.1.1"]["1"] && SAFE_ADDRESSES["1.1.1"]["1"]["proxy_factory"] || null;
            console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - factoryAddress: " + JSON.stringify(factoryAddress));
            const factoryABI = ABIS["1.1.1"] && ABIS["1.1.1"]["proxy_factory"] || null;
            const safeABI130 = ABIS["1.3.0"].gnosis_safe;
            const safeABI141 = ABIS["1.4.1"].gnosis_safe;
            // console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - safeABI141: " + JSON.stringify(safeABI141));
            const safeInterface141 = new ethers.utils.Interface(safeABI141);
            const safeInterface130 = new ethers.utils.Interface(safeABI130);

            let indexToAddress = [];
            let addressToIndex = {};
            const indexToAddressDataItems = await db.cache.where("objectName").equals("indexToAddress").toArray();
            if (indexToAddressDataItems.length == 1) {
              indexToAddress = indexToAddressDataItems[0].object;
              for (const [index, address] of indexToAddress.entries()) {
                addressToIndex[address] = index;
              }
            }
            let indexToTxHash = [];
            let txHashToIndex = {};
            const indexToTxHashDataItems = await db.cache.where("objectName").equals("indexToTxHash").toArray();
            if (indexToTxHashDataItems.length == 1) {
              indexToTxHash = indexToTxHashDataItems[0].object;
              for (const [index, txHash] of indexToTxHash.entries()) {
                txHashToIndex[txHash] = index;
              }
            }
            if (!(factoryAddress in addressToIndex)) {
              addressToIndex[factoryAddress] = indexToAddress.length;
              indexToAddress.push(factoryAddress);
            }
            const factoryAddresses = this.factories;
            for (const factoryAddress in factoryAddresses) {
              if (!(factoryAddress in addressToIndex)) {
                addressToIndex[factoryAddress] = indexToAddress.length;
                indexToAddress.push(factoryAddress);
              }
            }
            console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - factoryAddresses: " + JSON.stringify(factoryAddresses));

            // const latest = await db.safeFactoryEvents.where('[chainId+blockNumber+logIndex]').between([chainId, Dexie.minKey, Dexie.minKey],[chainId, Dexie.maxKey, Dexie.maxKey]).last();
            // console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - latest: " + JSON.stringify(latest));
            const latest = null;
            // TODO: TEST
            const startBlock = latest ? parseInt(latest.blockNumber) + 1: latestBlockNumber - 10000;
            // const startBlock = latest ? parseInt(latest.blockNumber) + 1: 0;
            this.sync.completed = startBlock;
            console.log(moment().format("HH:mm:ss") + " retrieveSafeEvents - startBlock: " + startBlock);
            await getLogsFromRange(startBlock, latestBlockNumber);

            Vue.set(this, "addressToIndex", addressToIndex);
            Vue.set(this, "indexToAddress", indexToAddress);
            await db.cache.put({ objectName: "indexToAddress", object: indexToAddress }).then (function() {
            }).catch(function(error) {
              console.log("error: " + error);
            });
            Vue.set(this, "txHashToIndex", txHashToIndex);
            Vue.set(this, "indexToTxHash", indexToTxHash);
            await db.cache.put({ objectName: "indexToTxHash", object: indexToTxHash }).then (function() {
            }).catch(function(error) {
              console.log("error: " + error);
            });
            await this.loadCurrentData();
            this.sync.section = null;
          },

          async resetData() {
            this.$bvModal.msgBoxConfirm('Reset all data?', {
                title: 'Please Confirm',
                size: 'sm',
                buttonSize: 'sm',
                okVariant: 'danger',
                okTitle: 'Yes',
                cancelTitle: 'No',
                footerClass: 'p-2',
                hideHeaderClose: false,
                // centered: true
              })
              .then(async value1 => {
                if (value1) {
                  event.preventDefault();
                  delete localStorage.gnosisSafeExplorerSettings;
                  const db = new Dexie(this.db.name);
                  db.version(this.db.version).stores(this.db.schemaDefinition);
                  const status = await db.cache.clear();
                  db.close();
                  alert('This page will be reloaded in 5 seconds.')
                  setTimeout(function() {
                    window.location.reload();
                  }, 5000);
                }
              })
              .catch(err => {
                // An error occurred
              });
          },

          async syncBlockTimestamps(provider) {
            console.log(moment().format("HH:mm:ss") + " syncBlockTimestamps BEGIN");
            const blockTimestamps = this.blockTimestamps;
            if (!(this.chainId in blockTimestamps)) {
              blockTimestamps[this.chainId] = {};
            }
            const events = this.events[this.chainId] || {};
            const newBlockNumbersMap = {};
            for (const blockNumber of Object.keys(events)) {
              if (!(blockNumber in blockTimestamps[this.chainId]) && !(blockNumber in newBlockNumbersMap)) {
                newBlockNumbersMap[blockNumber] = true;
              }
            }
            const newBlockNumbers = Object.keys(newBlockNumbersMap);
            this.sync.completed = 0;
            this.sync.total = newBlockNumbers.length;
            this.sync.section = 'Block Timestamps';
            for (let i = 0; i < newBlockNumbers.length && !this.sync.halt; i++) {
              const block = await provider.getBlock(parseInt(newBlockNumbers[i]));
              blockTimestamps[this.chainId][newBlockNumbers[i]] = parseInt(block.timestamp);
              this.sync.completed++;
            }
            if (!this.sync.halt) {
              localStorage.approvalBlockTimestamps = JSON.stringify(blockTimestamps);
              Vue.set(this, 'blockTimestamps', blockTimestamps);
            }
            console.log(moment().format("HH:mm:ss") + " syncBlockTimestamps END");
          },

          saveSettings() {
            // console.log(moment().format("HH:mm:ss") + " saveSettings: " + JSON.stringify(this.settings, null, 2));
            localStorage.gnosisSafeExplorerSettings = JSON.stringify(this.settings);
          },
          async processNewBlock(blockNumber) {
            console.log(moment().format("HH:mm:ss") + " processNewBlock[" + this.chainId + "] #" + this.commify0(blockNumber) + ", latest #" + this.commify0(this.blockNumber) + " @ " + moment.unix(this.timestamp).format("YYYY-MM-DD HH:mm:ss") + " " + moment.unix(this.timestamp).fromNow());
          },
          async halt() {
            this.sync.halt = true;
            console.log(moment().format("HH:mm:ss") + " halt()");
          },
          commify0(n) {
            if (n != null) {
              return Number(n).toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 0 });
            }
            return null;
          },
          formatTokens(token, tokens, precision = 9) {
            if (token == "eth") {
              try {
                if (precision == 0) {
                  return tokens ? ethers.utils.formatEther(tokens).replace(/\B(?<!\.\d*)(?=(\d{3})+(?!\d))/g, ",") : null;
                } else {
                  return tokens ? parseFloat(ethers.utils.formatEther(tokens)).toFixed(precision) : null;
                }
              } catch (err) {
              }
              return tokens.toFixed(precision);
            } else {
              if (token in this.settings.addresses) {
                const decimals = this.settings.addresses[token].decimals || 18;
                try {
                  if (precision == 0) {
                    return tokens ? ethers.utils.formatUnits(tokens, decimals).replace(/\B(?<!\.\d*)(?=(\d{3})+(?!\d))/g, ",") : null;
                  } else {
                    return tokens ? parseFloat(ethers.utils.formatUnits(tokens, decimals)).toFixed(precision) : null;
                  }
                } catch (err) {
                }
                return tokens.toFixed(precision);
              }
            }
            return tokens;
          },
          formatETH(e, precision = 9) {
            try {
              if (precision == 0) {
                return e ? ethers.utils.formatEther(e) : null;
              } else {
                return e ? parseFloat(ethers.utils.formatEther(e)).toFixed(precision) : null;
              }
            } catch (err) {
            }
            return e.toFixed(precision);
          },
          formatDecimals(e, decimals = 18) {
            return e ? ethers.utils.formatUnits(e, decimals) : null;
          },
          formatTimestamp(ts) {
            if (ts != null) {
              // if (this.settings.reportingDateTime == 1) {
              //   return moment.unix(ts).utc().format("YYYY-MM-DD HH:mm:ss");
              // } else {
                return moment.unix(ts).format("YYYY-MM-DD HH:mm:ss");
              // }
            }
            return null;
          },
          formatTimeDiff(unixtime) {
            if (!unixtime) {
              return "";
            } else {
              return moment.unix(unixtime).fromNow();
            }
          },

          lookupAddress(a) {
            if (a.toString().length < 42) {
              a = this.indexToAddress[a];
            }
            return a;
          },
          lookupName(a) {
            if (a.toString().length < 42) {
              if (this.chainId && (a in this.safes[this.chainId])) {
                a = "Safe " + this.indexToAddress[a].substring(0, 8) + '...' + this.indexToAddress[a].slice(-6);
              } else {
                a = this.indexToAddress[a];
              }
            } else {
              if (this.chainId && (this.addressToIndex[a] in this.safes[this.chainId])) {
                a = "Safe " + a.substring(0, 8) + '...' + a.slice(-6);
              }
            }
            if (a in this.safeContractNames) {
              a = this.safeContractNames[a];
            } else if (a in this.modalSafeOwners) {
              a = this.modalSafeOwners[a] + " " + a.substring(0, 8) + '...' + a.slice(-6);
            }
            return a;
          },

          nameOrShortAddress(address, length = 0) {
            let result = null;
            if (address == "eth") {
              return "ETH";
            }
            if (address in this.settings.addresses) {
              result = this.settings.addresses[address].name;
            }
            if (!result) {
              if (address in CUSTOMNAMES) {
                result = CUSTOMNAMES[address][1];
              } else if (address) {
                // if (address.match(/0x[a-f0-9]{40}/g)) {
                  result = address.substring(0, 6) + '...' + address.slice(-4);
                // } else {
                //   result = address;
                // }
              }
            }
            return result;
          },
          addressDescription(address) {
            const accounts = this.accounts[this.chainId] || {};
            if (address in accounts) {
              result = "address=" + address;
              for (let key of ['type', 'customType', 'symbol', 'name', 'customName', 'decimals', 'customDecimals', 'source']) {
                if (key in accounts[address] && accounts[address][key]) {
                  result = result + "; " + key + "=" + accounts[address][key];
                }
              }
            } else {
              result = address;
            }
            return result;
          },
          copyToClipboard(str) {
            navigator.clipboard.writeText(str);
          },
          async connectToWeb3() {
            if (!window.ethereum) {
              this.connected = false;
            } else {
              try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                this.connected = window.ethereum.isConnected();
              } catch (e) {
                console.log("window.ethereum.request error: " + e.message);
                this.connected = false;
              }
            }
            if (!this.connected) {
              alert("Please use the https://metamask.io addon with Firefox, Chromium, Opera or Chrome, or any other other web3 browser, for web3 data retrieval. And refresh!");
            } else {
              const t = this;
              function handleChainChanged(_chainId) {
                t.chainId = _chainId;
                console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleChainChanged - this.chainId: " + t.chainId);
                alert('Ethereum chain has changed - reloading this page.')
                window.location.reload();
              }
              window.ethereum.on('chainChanged', handleChainChanged);
              const provider = new ethers.providers.Web3Provider(window.ethereum);
              async function handleAccountsChanged(accounts) {
                const signer = provider.getSigner();
                t.coinbase = await signer.getAddress();
                console.log(moment().format("HH:mm:ss") + " connectToWeb3 - handleAccountsChanged: " + t.coinbase);
              }
              window.ethereum.on('accountsChanged', handleAccountsChanged);
              async function handleNewBlock(blockNumber) {
                if (!t.blockNumber || blockNumber > t.blockNumber) {
                  const block = await provider.getBlock("latest");
                  t.blockNumber = block.number;
                  t.timestamp = block.timestamp;
                  await t.processNewBlock(blockNumber);
                }
              }
              provider.on("block", handleNewBlock);
              const signer = provider.getSigner();
              this.coinbase = await signer.getAddress();
              const network = await provider.getNetwork();
              this.chainId = network.chainId;
              console.log(moment().format("HH:mm:ss") + " connectToWeb3[" + this.chainId + "]");
            }
          },
        },

        // --- MOUNTED ---
        mounted() {
          // (async() => {
          //   await this.connectToWeb3();
          // })();
          if ('gnosisSafeExplorerChainId' in localStorage) {
            this.chainId = localStorage.gnosisSafeExplorerChainId;
            // console.log(moment().format("HH:mm:ss") + " mounted - this.chainId: " + this.chainId);
          }
          // if ('gnosisSafeExplorerCoinbase' in localStorage) {
          //   this.coinbase = localStorage.gnosisSafeExplorerCoinbase;
          // }
          if ('gnosisSafeExplorerSettings' in localStorage) {
            const tempSettings = JSON.parse(localStorage.gnosisSafeExplorerSettings);
            if ('version' in tempSettings && tempSettings.version == this.settings.version) {
              this.settings = tempSettings;
              if (this.settings.safesTable.currentPage > 1) {
                this.settings.safesTable.currentPage = 1;
              }
              // console.log(moment().format("HH:mm:ss") + " mounted - this.settings: " + JSON.stringify(this.settings, null, 2).substring(0, 200));
            }
          }
          (async() => {
            await this.loadCurrentData();
          })();
        },
      })
    </script>
  </body>
</html>
